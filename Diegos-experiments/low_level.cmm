#include "Cmm.h"

INFO_TABLE_CONSTR ( my_start, 0, 0, 1, 1, "my start description", "my start type")
{
  foreign "C" debugBelch("hello cmm!\n");

  jump my_main();
}

// this is how RTS finds the entry points, the "ZCMain_main_closure" is hardwired
CLOSURE (ZCMain_main_closure, my_start);

my_main()
{
  (bits64 res) = call sum(0, 1, 100000);
  foreign "C" debugBelch("%ld\n", res);

  // exit program
  jump stg_stop_thread_info();
}



bar
{
  // this is low-level cmm code, indicated by the fact that we did not
  // put an argument list on bar.

 // bits64 x;
 // x = R1;  // the calling convention is explicit: better be careful
           // that this works on all platforms!

  jump %ENTRY_CODE(Sp(0))[];
  //jump %ENTRY_CODE(Sp(0))[] note this is the version found in
  // documentation, notice the two errors : https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Cmm/Parser.y
}


sum {
 cr: 
          // _cq::I64 = R2;
          // _cp::I64 = R1;
           //tick src<test06_sum.cmm:(72,33)-(75,1)>
           bits64 x;
           x = R1 + R2;
           R1 = x;
           //call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
          

  jump %ENTRY_CODE(Sp(0))[R1];
}


simple_sum( bits64 b, bits64 a ){

   return(a + b);
}


sum2() {
  // Parameters assumed to be in registers: R1 (acc), R2 (from), R3 (to)
  entry:
    if (R2 > R3) goto exit;    // Compare from (R2) and to (R3)
    R1 = R1 + R2;              // acc += from
    R2 = R2 + 1;               // from += 1
    goto entry;                 // Tail recursion as a loop

  exit:
    call "RETURN" (R1);         // Return result in R1
}


simple_sum_4 { //  [R2, R1]
    R1 = 0;
    R2 = 0;
    R3 = 0;
    R4 = 0;
    R5 = 0;
    R6 = 0;
    R7 = 0;
    R8 = 0;
    R9 = 0;
    cr: // global
        bits64 _cq;
        _cq = R2;
        bits64 _cp;
       _cp = R1;
       R1 = _cq + _cp;

       // this
       //jump %ENTRY_CODE(bits64[Sp])[R1];
       // or this
       jump (bits64[Sp])[R1,R2,R3,R4,R5,R6,R7,R8,R9];
}

sum22(bits64 input) {
    bits64 internal;
    if (input == 0) { internal = 5;}    // Compare from (R2) and to (R3)
    else { internal = 6;}

    return (internal);
}


ifsum(bits64 acc, bits64 from, bits64 to)
{
  if (from > to) {
    return (acc);
  } else {
    jump sum(acc + from, from + 1, to);
  }
}

// parameter, basic blocks, control flow
//these are ways low level ( haskell structure ) cmm differs from the Parser
// i should write code that uses such features to :
// compared the parsed and pretty printed versions
// to see how they get implemented in the haskell data structure. Example : see how the pretty printed implements if, to what part of the data structure that corresponds to
 

 // tell datalog, previous gSoc participant and GHC mailing list about this