/*
 * An update frame where the updatee has been replaced by a BLACKHOLE
 * closure by threadPaused.  We may have threads to wake up, and we
 * also have to check whether the blackhole has been updated by
 * another thread in the meantime.
 */
INFO_TABLE_RET ( stg_marked_upd_frame, UPDATE_FRAME,
                 UPDATE_FRAME_FIELDS(W_,P_,info_ptr,_ccs,_unused,updatee) )
    return (P_ ret) /* the closure being returned */
{
    W_ v;

    ASSERT(HpAlloc == 0); // Note [HpAlloc]

    // we know the closure is a BLACKHOLE
    v = %acquire StgInd_indirectee(updatee);

    if (GETTAG(v) != 0) (likely: False) {
        // updated by someone else: discard our value and use the
        // other one to increase sharing, but check the blocking
        // queues to see if any threads were waiting on this BLACKHOLE.
        ccall checkBlockingQueues(MyCapability() "ptr", CurrentTSO "ptr");
        return (v);
    }

    // common case: it is still our BLACKHOLE
    if (v == CurrentTSO) (likely: True) {
        updateWithIndirection(updatee, ret, return (ret));
    }

    // The other cases are all handled by the generic code
    ccall updateThunk (MyCapability() "ptr", CurrentTSO "ptr",
                       updatee "ptr", ret "ptr");

    return (ret);
}
