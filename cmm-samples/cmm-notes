https://takenobu-hs.github.io/downloads/haskell_ghc_reading_guide.pdf
https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/cmm-syntax
https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/cmm-type

  P@decimal             { global_regN (\n -> VanillaReg n VGcPtr) }
  R@decimal             { global_regN (\n -> VanillaReg n VNonGcPtr) }
  F@decimal             { global_regN FloatReg }
  D@decimal             { global_regN DoubleReg }
  L@decimal             { global_regN LongReg }
  Sp                    { global_reg Sp }
  SpLim                 { global_reg SpLim }
  Hp                    { global_reg Hp }
  HpLim                 { global_reg HpLim }
  CCCS                  { global_reg CCCS }
  CurrentTSO            { global_reg CurrentTSO }
  CurrentNursery        { global_reg CurrentNursery }
  HpAlloc               { global_reg HpAlloc }
  BaseReg               { global_reg BaseReg }
  MachSp                { global_reg MachSp }
  UnwindReturnReg       { global_reg UnwindReturnReg }

Memory ordering
---------------

Cmm respects the C11 memory model and distinguishes between non-atomic and
atomic memory accesses. In C11 fashion, atomic accesses can provide a number of
memory ordering guarantees. These are supported in Cmm syntax as follows:

    W_[ptr] = ...;            // a non-atomic store
    %relaxed W_[ptr] = ...;   // an atomic store with relaxed ordering semantics
    %release W_[ptr] = ...;   // an atomic store with release ordering semantics

    x = W_(ptr);              // a non-atomic load
    x = %relaxed W_[ptr];     // an atomic load with relaxed ordering
    x = %acquire W_[ptr];     // an atomic load with acquire ordering
    // or equivalently...
    x = prim %load_acquire64(ptr);

dereference :: { CmmParse (AlignmentSpec, CmmExpr) }
        : '^' '[' expr ']'       { do ptr <- $3; return (Unaligned, ptr) }
        | '[' expr ']'           { do ptr <- $2; return (NaturallyAligned, ptr) }


info    :: { CmmParse (CLabel, Maybe CmmInfoTable, [LocalReg]) }
        : NAME
        | 'INFO_TABLE' '(' NAME ',' INT ',' INT ',' INT ',' STRING ',' STRING ')'
                -- ptrs, nptrs, closure type, description, type
        | 'INFO_TABLE_FUN' '(' NAME ',' INT ',' INT ',' INT ',' STRING ',' STRING ',' INT ',' INT ')'
                -- ptrs, nptrs, closure type, description, type, arity, fun type
                -- we leave most of the fields zero here.  This is only used
                -- to generate the BCO and CONTINUATION info tables in the RTS at the moment.
        | 'INFO_TABLE_CONSTR' '(' NAME ',' INT ',' INT ',' INT ',' INT ',' STRING ',' STRING ')'
                -- ptrs, nptrs, tag, closure type, description, type
                     -- If profiling is on, this string gets duplicated,
                     -- but that's the way the old code did it we can fix it some other time.
        | 'INFO_TABLE_SELECTOR' '(' NAME ',' INT ',' INT ',' STRING ',' STRING ')'
                -- selector, closure type, description, type
        | 'INFO_TABLE_RET' '(' NAME ',' INT ')'
                -- closure type (no live regs)
        | 'INFO_TABLE_RET' '(' NAME ',' INT ',' formals0 ')'
                -- closure type, live regs

expr    :: { CmmParse CmmExpr }
        : expr '/' expr                 { mkMachOp MO_U_Quot [$1,$3] }
        | expr '*' expr                 { mkMachOp MO_Mul [$1,$3] }
        | expr '%' expr                 { mkMachOp MO_U_Rem [$1,$3] }
        | expr '-' expr                 { mkMachOp MO_Sub [$1,$3] }
        | expr '+' expr                 { mkMachOp MO_Add [$1,$3] }
        | expr '>>' expr                { mkMachOp MO_U_Shr [$1,$3] }
        | expr '<<' expr                { mkMachOp MO_Shl [$1,$3] }
        | expr '&' expr                 { mkMachOp MO_And [$1,$3] }
        | expr '^' expr                 { mkMachOp MO_Xor [$1,$3] }
        | expr '|' expr                 { mkMachOp MO_Or [$1,$3] }
        | expr '>=' expr                { mkMachOp MO_U_Ge [$1,$3] }
        | expr '>' expr                 { mkMachOp MO_U_Gt [$1,$3] }
        | expr '<=' expr                { mkMachOp MO_U_Le [$1,$3] }
        | expr '<' expr                 { mkMachOp MO_U_Lt [$1,$3] }
        | expr '!=' expr                { mkMachOp MO_Ne [$1,$3] }
        | expr '==' expr                { mkMachOp MO_Eq [$1,$3] }
        | '~' expr                      { mkMachOp MO_Not [$2] }
        | '-' expr                      { mkMachOp MO_S_Neg [$2] }
        | expr0 '`' NAME '`' expr0      {% do { mo <- nameToMachOp $3 ;
                                                return (mkMachOp mo [$1,$5]) } }
        | expr0                         { $1 }

expr0   :: { CmmParse CmmExpr }
        : INT   maybe_ty         { return (CmmLit (CmmInt $1 (typeWidth $2))) }
        | FLOAT maybe_ty         { return (CmmLit (CmmFloat $1 (typeWidth $2))) }
        | STRING                 { do s <- code (newStringCLit $1);
                                      return (CmmLit s) }
        | reg                    { $1 }
        | type dereference       { do (align, ptr) <- $2; return (CmmLoad ptr $1 align) }
        | '%' NAME '(' exprs0 ')' {% exprOp $2 $4 }
        | '(' expr ')'           { $2 }

type    :: { CmmType }
        : 'bits8'               { b8 }
        : 'bits16'              { b16 }
        | 'bits32'              { b32 }
        | 'bits64'              { b64 }
        | 'bits128'             { b128 }
        | 'bits256'             { b256 }
        | 'bits512'             { b512 }
        | 'float32'             { f32 }
        | 'float64'             { f64 }
        | 'gcptr'               {% do platform <- PD.getPlatform; return $ gcWord platform }

-- we understand a subset of C-- primitives:
machOps :: UniqFM FastString (Width -> MachOp)
machOps = listToUFM $
        map (\(x, y) -> (mkFastString x, y)) [
        ( "add",        MO_Add ),
        ( "sub",        MO_Sub ),
        ( "eq",         MO_Eq ),
        ( "ne",         MO_Ne ),
        ( "mul",        MO_Mul ),
        ( "mulmayoflo",  MO_S_MulMayOflo ),
        ( "neg",        MO_S_Neg ),
        ( "quot",       MO_S_Quot ),
        ( "rem",        MO_S_Rem ),
        ( "divu",       MO_U_Quot ),
        ( "modu",       MO_U_Rem ),

        ( "ge",         MO_S_Ge ),
        ( "le",         MO_S_Le ),
        ( "gt",         MO_S_Gt ),
        ( "lt",         MO_S_Lt ),

        ( "geu",        MO_U_Ge ),
        ( "leu",        MO_U_Le ),
        ( "gtu",        MO_U_Gt ),
        ( "ltu",        MO_U_Lt ),

        ( "and",        MO_And ),
        ( "or",         MO_Or ),
        ( "xor",        MO_Xor ),
        ( "com",        MO_Not ),
        ( "shl",        MO_Shl ),
        ( "shrl",       MO_U_Shr ),
        ( "shra",       MO_S_Shr ),

        ( "fadd",       MO_F_Add ),
        ( "fsub",       MO_F_Sub ),
        ( "fneg",       MO_F_Neg ),
        ( "fmul",       MO_F_Mul ),
        ( "fquot",      MO_F_Quot ),

        ( "feq",        MO_F_Eq ),
        ( "fne",        MO_F_Ne ),
        ( "fge",        MO_F_Ge ),
        ( "fle",        MO_F_Le ),
        ( "fgt",        MO_F_Gt ),
        ( "flt",        MO_F_Lt ),

        ( "lobits8",  flip MO_UU_Conv W8  ),
        ( "lobits16", flip MO_UU_Conv W16 ),
        ( "lobits32", flip MO_UU_Conv W32 ),
        ( "lobits64", flip MO_UU_Conv W64 ),

        ( "zx16",     flip MO_UU_Conv W16 ),
        ( "zx32",     flip MO_UU_Conv W32 ),
        ( "zx64",     flip MO_UU_Conv W64 ),

        ( "sx16",     flip MO_SS_Conv W16 ),
        ( "sx32",     flip MO_SS_Conv W32 ),
        ( "sx64",     flip MO_SS_Conv W64 ),

        ( "f2f32",    flip MO_FF_Conv W32 ),  -- TODO; rounding mode
        ( "f2f64",    flip MO_FF_Conv W64 ),  -- TODO; rounding mode
        ( "f2i8",     flip MO_FS_Conv W8 ),
        ( "f2i16",    flip MO_FS_Conv W16 ),
        ( "f2i32",    flip MO_FS_Conv W32 ),
        ( "f2i64",    flip MO_FS_Conv W64 ),
        ( "i2f32",    flip MO_SF_Conv W32 ),
        ( "i2f64",    flip MO_SF_Conv W64 )
        ]

callishMachOps :: Platform -> UniqFM FastString ([CmmExpr] -> (CallishMachOp, [CmmExpr]))
callishMachOps platform = listToUFM $
        map (\(x, y) -> (mkFastString x, y)) [

        ( "pow64f", (MO_F64_Pwr,) ),
        ( "sin64f", (MO_F64_Sin,) ),
        ( "cos64f", (MO_F64_Cos,) ),
        ( "tan64f", (MO_F64_Tan,) ),
        ( "sinh64f", (MO_F64_Sinh,) ),
        ( "cosh64f", (MO_F64_Cosh,) ),
        ( "tanh64f", (MO_F64_Tanh,) ),
        ( "asin64f", (MO_F64_Asin,) ),
        ( "acos64f", (MO_F64_Acos,) ),
        ( "atan64f", (MO_F64_Atan,) ),
        ( "asinh64f", (MO_F64_Asinh,) ),
        ( "acosh64f", (MO_F64_Acosh,) ),
        ( "log64f", (MO_F64_Log,) ),
        ( "log1p64f", (MO_F64_Log1P,) ),
        ( "exp64f", (MO_F64_Exp,) ),
        ( "expM164f", (MO_F64_ExpM1,) ),
        ( "fabs64f", (MO_F64_Fabs,) ),
        ( "sqrt64f", (MO_F64_Sqrt,) ),

        ( "pow32f", (MO_F32_Pwr,) ),
        ( "sin32f", (MO_F32_Sin,) ),
        ( "cos32f", (MO_F32_Cos,) ),
        ( "tan32f", (MO_F32_Tan,) ),
        ( "sinh32f", (MO_F32_Sinh,) ),
        ( "cosh32f", (MO_F32_Cosh,) ),
        ( "tanh32f", (MO_F32_Tanh,) ),
        ( "asin32f", (MO_F32_Asin,) ),
        ( "acos32f", (MO_F32_Acos,) ),
        ( "atan32f", (MO_F32_Atan,) ),
        ( "asinh32f", (MO_F32_Asinh,) ),
        ( "acosh32f", (MO_F32_Acosh,) ),
        ( "log32f", (MO_F32_Log,) ),
        ( "log1p32f", (MO_F32_Log1P,) ),
        ( "exp32f", (MO_F32_Exp,) ),
        ( "expM132f", (MO_F32_ExpM1,) ),
        ( "fabs32f", (MO_F32_Fabs,) ),
        ( "sqrt32f", (MO_F32_Sqrt,) ),

        ( "read_barrier", (MO_ReadBarrier,)),
        ( "write_barrier", (MO_WriteBarrier,)),
        ( "memcpy", memcpyLikeTweakArgs MO_Memcpy ),
        ( "memset", memcpyLikeTweakArgs MO_Memset ),
        ( "memmove", memcpyLikeTweakArgs MO_Memmove ),
        ( "memcmp", memcpyLikeTweakArgs MO_Memcmp ),

        ( "suspendThread", (MO_SuspendThread,) ),
        ( "resumeThread",  (MO_ResumeThread,) ),

        ( "prefetch0", (MO_Prefetch_Data 0,)),
        ( "prefetch1", (MO_Prefetch_Data 1,)),
        ( "prefetch2", (MO_Prefetch_Data 2,)),
        ( "prefetch3", (MO_Prefetch_Data 3,))
    ] ++ concat
    [ allWidths "popcnt" MO_PopCnt
    , allWidths "pdep" MO_Pdep
    , allWidths "pext" MO_Pext
    , allWidths "cmpxchg" MO_Cmpxchg
    , allWidths "xchg" MO_Xchg
    , allWidths "load_relaxed" (\w -> MO_AtomicRead w MemOrderAcquire)
    , allWidths "load_acquire" (\w -> MO_AtomicRead w MemOrderAcquire)
    , allWidths "load_seqcst" (\w -> MO_AtomicRead w MemOrderSeqCst)
    , allWidths "store_release" (\w -> MO_AtomicWrite w MemOrderRelease)
    , allWidths "store_seqcst" (\w -> MO_AtomicWrite w MemOrderSeqCst)
    ]

isPtrGlobalReg Sp                    = True
isPtrGlobalReg SpLim                 = True
isPtrGlobalReg Hp                    = True
isPtrGlobalReg HpLim                 = True
isPtrGlobalReg CCCS                  = True
isPtrGlobalReg CurrentTSO            = True
isPtrGlobalReg CurrentNursery        = True
isPtrGlobalReg (VanillaReg _ VGcPtr) = True
isPtrGlobalReg _                     = False

stmtMacros :: UniqFM FastString ([CmmExpr] -> FCode ())
stmtMacros = listToUFM [
  ( fsLit "CCS_ALLOC",             \[words,ccs]  -> profAlloc words ccs ),
  ( fsLit "ENTER_CCS_THUNK",       \[e] -> enterCostCentreThunk e ),

  ( fsLit "CLOSE_NURSERY",         \[]  -> emitCloseNursery ),
  ( fsLit "OPEN_NURSERY",          \[]  -> emitOpenNursery ),

  -- completely generic heap and stack checks, for use in high-level cmm.
  ( fsLit "HP_CHK_GEN",            \[bytes] ->
                                      heapStackCheckGen Nothing (Just bytes) ),
  ( fsLit "STK_CHK_GEN",           \[] ->
                                      heapStackCheckGen (Just (CmmLit CmmHighStackMark)) Nothing ),

  -- A stack check for a fixed amount of stack.  Sounds a bit strange, but
  -- we use the stack for a bit of temporary storage in a couple of primops
  ( fsLit "STK_CHK_GEN_N",         \[bytes] ->
                                      heapStackCheckGen (Just bytes) Nothing ),

  -- A stack check on entry to a thunk, where the argument is the thunk pointer.
  ( fsLit "STK_CHK_NP"   ,         \[node] -> entryHeapCheck' False node 0 [] (return ())),

  ( fsLit "LOAD_THREAD_STATE",     \[] -> emitLoadThreadState ),
  ( fsLit "SAVE_THREAD_STATE",     \[] -> emitSaveThreadState ),

  ( fsLit "SAVE_REGS",             \[] -> emitSaveRegs ),
  ( fsLit "RESTORE_REGS",          \[] -> emitRestoreRegs ),

  ( fsLit "PUSH_ARG_REGS",         \[live_regs] -> emitPushArgRegs live_regs ),
  ( fsLit "POP_ARG_REGS",          \[live_regs] -> emitPopArgRegs live_regs ),

  ( fsLit "LDV_ENTER",             \[e] -> ldvEnter e ),
  ( fsLit "LDV_RECORD_CREATE",     \[e] -> ldvRecordCreate e ),

  ( fsLit "PUSH_UPD_FRAME",        \[sp,e] -> emitPushUpdateFrame sp e ),
  ( fsLit "SET_HDR",               \[ptr,info,ccs] ->
                                        emitSetDynHdr ptr info ccs ),
  ( fsLit "TICK_ALLOC_PRIM",       \[hdr,goods,slop] ->
                                        tickyAllocPrim hdr goods slop ),
  ( fsLit "TICK_ALLOC_PAP",        \[goods,slop] ->
                                        tickyAllocPAP goods slop ),
  ( fsLit "TICK_ALLOC_UP_THK",     \[goods,slop] ->
                                        tickyAllocThunk goods slop ),
  ( fsLit "UPD_BH_UPDATABLE",      \[reg] -> emitBlackHoleCode reg )
 ]

exprMacros :: Profile -> DoAlignSanitisation -> UniqFM FastString ([CmmExpr] -> CmmExpr)
exprMacros profile align_check = listToUFM [
  ( fsLit "ENTRY_CODE",   \ [x] -> entryCode platform x ),
  ( fsLit "INFO_PTR",     \ [x] -> closureInfoPtr platform align_check x ),
  ( fsLit "STD_INFO",     \ [x] -> infoTable    profile x ),
  ( fsLit "FUN_INFO",     \ [x] -> funInfoTable profile x ),
  ( fsLit "GET_ENTRY",    \ [x] -> entryCode platform   (closureInfoPtr platform align_check x) ),
  ( fsLit "GET_STD_INFO", \ [x] -> infoTable profile    (closureInfoPtr platform align_check x) ),
  ( fsLit "GET_FUN_INFO", \ [x] -> funInfoTable profile (closureInfoPtr platform align_check x) ),
  ( fsLit "INFO_TYPE",    \ [x] -> infoTableClosureType profile x ),
  ( fsLit "INFO_PTRS",    \ [x] -> infoTablePtrs profile x ),
  ( fsLit "INFO_NPTRS",   \ [x] -> infoTableNonPtrs profile x )
  ]
