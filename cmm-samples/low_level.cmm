#include "Cmm.h"

INFO_TABLE_CONSTR ( my_start, 0, 0, 1, 1, "my start description", "my start type")
{
  foreign "C" debugBelch("hello cmm!\n");

  jump my_main();
}

// this is how RTS finds the entry points, the "ZCMain_main_closure" is hardwired
CLOSURE (ZCMain_main_closure, my_start);

my_main()
{
  (bits64 res) = call sum(0, 1, 100000);
  foreign "C" debugBelch("%ld\n", res);

  // exit program
  jump stg_stop_thread_info();
}




bar
{
  // this is low-level cmm code, indicated by the fact that we did not
  // put an argument list on bar.

 // bits64 x;
 // x = R1;  // the calling convention is explicit: better be careful
           // that this works on all platforms!

  jump %ENTRY_CODE(Sp(0))[];
}


simple_sum2 {
 cr: 
          // _cq::I64 = R2;
          // _cp::I64 = R1;
           //tick src<test06_sum.cmm:(72,33)-(75,1)>
           bits64 x;
           x = R1 + R2;
           R1 = x;
           //call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
          

  jump %ENTRY_CODE(Sp(0))[R1];
}


sum {
 cr: 
          // _cq::I64 = R2;
          // _cp::I64 = R1;
           //tick src<test06_sum.cmm:(72,33)-(75,1)>
           bits64 x;
           x = R1 + R2;
           R1 = x;
           //call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
          

  jump %ENTRY_CODE(Sp(0))[R1];
}


simple_sum( bits64 b, bits64 a ){

   return(a + b);
}
